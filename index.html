<!DOCTYPE html>
<html lang="en">
<head>
<title>magnus.games/vr</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<link type="text/css" rel="stylesheet" href="../three.js/examples/main.css">
</head>
<body>
<script type="module">

import * as THREE from '../three.js/build/three.module.js';
import { VRButton } from '../three.js/examples/jsm/webxr/VRButton.js';
import { XRControllerModelFactory } from '../three.js/examples/jsm/webxr/XRControllerModelFactory.js';
import { XRHandModelFactory } from '../three.js/examples/jsm/webxr/XRHandModelFactory.js';

let container;
let camera, scene, renderer;
let hand1, hand2;
let controller1, controller2;
let controllerGrip1, controllerGrip2;
let player;

function init() {
    container = document.createElement( 'div' );
    document.body.appendChild( container );
    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0x808080 );
    // camera
    camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 1000 );
    camera.rotation.order = 'YXZ'
    // light
    scene.add(new THREE.AmbientLight(0xffffff));
    //scene.add( new THREE.HemisphereLight( 0x808080, 0x606060, 0.8 ) );
    // renderer
    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = true;
    renderer.xr.enabled = true;
    container.appendChild( renderer.domElement );
    // vr button
    document.body.appendChild( VRButton.createButton( renderer ) );
    // controllers
    controller1 = renderer.xr.getController( 0 );
    scene.add( controller1 );
    controller2 = renderer.xr.getController( 1 );
    scene.add( controller2 );
    const controllerModelFactory = new XRControllerModelFactory();
    const handModelFactory = new XRHandModelFactory().setPath( "./models/fbx/" );
    // Hand 1
    controllerGrip1 = renderer.xr.getControllerGrip( 0 );
    controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
    scene.add( controllerGrip1 );
    hand1 = renderer.xr.getHand( 0 );
    hand1.add( handModelFactory.createHandModel( hand1 ) );
    scene.add( hand1 );
    // Hand 2
    controllerGrip2 = renderer.xr.getControllerGrip( 1 );
    controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
    scene.add( controllerGrip2 );
    hand2 = renderer.xr.getHand( 1 );
    hand2.add( handModelFactory.createHandModel( hand2 ) );
    scene.add( hand2 );
    // lines from controllers
    const geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -1 ) ] );
    const line = new THREE.Line( geometry );
    line.name = 'line';
    line.scale.z = 10;
    controller1.add( line.clone() );
    controller2.add( line.clone() );
    // xyz axis
    var axesHelper = new THREE.AxesHelper(1);
    scene.add( axesHelper );
    // resize window
    window.addEventListener( 'resize', onWindowResize );
    // Create player object
    player = new THREE.Object3D();
    player.rotation.y = Math.PI * 0.25;
    player.position.y = 1.8;
    scene.add(player);
    const playerObjects = [
        camera,
        controller1,
        controller2,
        controllerGrip1,
        controllerGrip2,
        hand1,
        hand2
    ];
    playerObjects.forEach((object) => player.add(object));
}

function buildScene(){
    var floorRadius = 40;
    var pillarRadius = 1;
    var pillarHeight = 10;
    var xCenter,xSize,yCenter,ySize,zCenter,zSize,red,green,blue;
    //floor
    xCenter = 0;
    xSize = floorRadius * 2;
    yCenter = -1;
    ySize = 2;
    zCenter = 0;
    zSize = floorRadius * 2;
    red = 0.8;
    green = 0.8;
    blue = 0.8;
    cuboid(xCenter,xSize,yCenter,ySize,zCenter,zSize,red,green,blue,)
    //pillars
    xCenter = 0 - floorRadius + pillarRadius;
    xSize = pillarRadius * 2;
    yCenter = pillarHeight * 0.5;
    ySize = pillarHeight;
    zCenter = 0 - floorRadius + pillarRadius;
    zSize = pillarRadius * 2;
    red = 1;
    green = 0;
    blue = 0;
    cuboid(xCenter,xSize,yCenter,ySize,zCenter,zSize,red,green,blue)
    xCenter = 0 - floorRadius + pillarRadius;
    xSize = pillarRadius * 2;
    yCenter = pillarHeight * 0.5;
    ySize = pillarHeight;
    zCenter = 0 + floorRadius - pillarRadius;
    zSize = pillarRadius * 2;
    red = 0;
    green = 1;
    blue = 0;
    cuboid(xCenter,xSize,yCenter,ySize,zCenter,zSize,red,green,blue)
    xCenter = 0 + floorRadius - pillarRadius;
    xSize = pillarRadius * 2;
    yCenter = pillarHeight * 0.5;
    ySize = pillarHeight;
    zCenter = 0 - floorRadius + pillarRadius;
    zSize = pillarRadius * 2;
    red = 1;
    green = 1;
    blue = 0;
    cuboid(xCenter,xSize,yCenter,ySize,zCenter,zSize,red,green,blue)
    xCenter = 0 + floorRadius - pillarRadius;
    xSize = pillarRadius * 2;
    yCenter = pillarHeight * 0.5;
    ySize = pillarHeight;
    zCenter = 0 + floorRadius - pillarRadius;
    zSize = pillarRadius * 2;
    red = 0;
    green = 0;
    blue = 1;
    cuboid(xCenter,xSize,yCenter,ySize,zCenter,zSize,red,green,blue)

}

function cuboid(xCenter,xSize,yCenter,ySize,zCenter,zSize,red,green,blue){
    var edges;
    var geometry;
    var line;
    var material;
    var mesh;
    geometry = new THREE.BoxGeometry(xSize, ySize, zSize);
    material = new THREE.MeshStandardMaterial();
    material.color.setRGB(red,green,blue);
    mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = xCenter;
    mesh.position.y = yCenter;
    mesh.position.z = zCenter;
    scene.add(mesh);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    renderer.setAnimationLoop(render);
}

function render() {
    renderer.render(scene, camera);
}

function onDocumentMouseMove( event ) {
    event.preventDefault();
    if ( isMouseDown ) {
        camera.rotation.y = tempCameraRotationY + ((event.clientX - onMouseDownPositionX) * 0.002);
        camera.rotation.x = tempCameraRotationX + ((event.clientY - onMouseDownPositionY) * 0.002);
    }
}

function onDocumentMouseDown( event ) {
    event.preventDefault();
    isMouseDown = true;
    onMouseDownPositionX = event.clientX;
    onMouseDownPositionY = event.clientY;
    tempCameraRotationY = camera.rotation.y;
    tempCameraRotationX = camera.rotation.x;
}

function onDocumentMouseUp( event ) {
    event.preventDefault();
    isMouseDown = false;
}

// globals
var turnEnabled = true;
var isMouseDown = false;
var onMouseDownPositionX = 0;
var onMouseDownPositionY = 0;
var tempCameraRotationY = 0;
var tempCameraRotationX = 0;

document.addEventListener( 'mousemove', onDocumentMouseMove, false );
document.addEventListener( 'mousedown', onDocumentMouseDown, false );
document.addEventListener( 'mouseup', onDocumentMouseUp, false );

init();
buildScene();
animate();

/*
const axes = source.gamepad.axes.slice(0);
console.log(axes)
axes.forEach((axis, index) => {
    console.log(axis)
if (index === 2 && handedness === 'left') {
        //player.position.z = axis[1];
}
if (index === 3 && handedness === 'right') {
    // up and down axis on right thumbstick
}
});
*/

</script>
</body>
</html>