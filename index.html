<!DOCTYPE html>
<html lang="en">
<head>
<title>magnus.games/vr_basic</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<link type="text/css" rel="stylesheet" href="../three.js/examples/main.css">
</head>
<body>
<script type="module">

    import * as THREE from '../three.js/build/three.module.js';
    import { VRButton } from '../three.js/examples/jsm/webxr/VRButton.js';

    let container;
    let camera, scene, renderer;
    let player;

    function init() {
        container = document.createElement( 'div' );
        document.body.appendChild(container);
        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0x808080 );
        // camera
        camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 1000 );
        camera.rotation.order = 'YXZ'
        // light
        scene.add(new THREE.AmbientLight(0xffffff));
        // renderer
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.shadowMap.enabled = true;
        renderer.xr.enabled = true;
        container.appendChild( renderer.domElement );
        // Create player object
        player = new THREE.Object3D();
        player.rotation.y = Math.PI * 0.25;
        player.position.y = 1.8;
        scene.add(player);
        player.add(camera);
        // vr button
        document.body.appendChild(VRButton.createButton(renderer));
    }

    function buildScene(){
        var floorRadius = 40;
        var pillarRadius = 1;
        var pillarHeight = 10;
        var xCenter,xSize,yCenter,ySize,zCenter,zSize,red,green,blue;
        //floor
        xCenter = 0;
        xSize = floorRadius * 2;
        yCenter = -1;
        ySize = 2;
        zCenter = 0;
        zSize = floorRadius * 2;
        red = 0.8;
        green = 0.8;
        blue = 0.8;
        cuboid(xCenter,xSize,yCenter,ySize,zCenter,zSize,red,green,blue,)
        //pillars
        xCenter = 0 - floorRadius + pillarRadius;
        xSize = pillarRadius * 2;
        yCenter = pillarHeight * 0.5;
        ySize = pillarHeight;
        zCenter = 0 - floorRadius + pillarRadius;
        zSize = pillarRadius * 2;
        red = 1;
        green = 0;
        blue = 0;
        cuboid(xCenter,xSize,yCenter,ySize,zCenter,zSize,red,green,blue)
        xCenter = 0 - floorRadius + pillarRadius;
        xSize = pillarRadius * 2;
        yCenter = pillarHeight * 0.5;
        ySize = pillarHeight;
        zCenter = 0 + floorRadius - pillarRadius;
        zSize = pillarRadius * 2;
        red = 0;
        green = 1;
        blue = 0;
        cuboid(xCenter,xSize,yCenter,ySize,zCenter,zSize,red,green,blue)
        xCenter = 0 + floorRadius - pillarRadius;
        xSize = pillarRadius * 2;
        yCenter = pillarHeight * 0.5;
        ySize = pillarHeight;
        zCenter = 0 - floorRadius + pillarRadius;
        zSize = pillarRadius * 2;
        red = 1;
        green = 1;
        blue = 0;
        cuboid(xCenter,xSize,yCenter,ySize,zCenter,zSize,red,green,blue)
        xCenter = 0 + floorRadius - pillarRadius;
        xSize = pillarRadius * 2;
        yCenter = pillarHeight * 0.5;
        ySize = pillarHeight;
        zCenter = 0 + floorRadius - pillarRadius;
        zSize = pillarRadius * 2;
        red = 0;
        green = 0;
        blue = 1;
        cuboid(xCenter,xSize,yCenter,ySize,zCenter,zSize,red,green,blue)

    }

    function cuboid(xCenter,xSize,yCenter,ySize,zCenter,zSize,red,green,blue){
        var edges;
        var geometry;
        var line;
        var material;
        var mesh;
        geometry = new THREE.BoxGeometry(xSize, ySize, zSize);
        material = new THREE.MeshStandardMaterial();
        material.color.setRGB(red,green,blue);
        mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = xCenter;
        mesh.position.y = yCenter;
        mesh.position.z = zCenter;
        scene.add(mesh);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        renderer.setAnimationLoop(render);
    }

    function render() {
        renderer.render(scene, camera);
    }

    function onDocumentMouseMove(event) {
        event.preventDefault();
        if (isMouseDown) {
            camera.rotation.y = tempCameraRotationY + ((event.clientX - onMouseDownPositionX) * 0.002);
            camera.rotation.x = tempCameraRotationX + ((event.clientY - onMouseDownPositionY) * 0.002);
        }
    }

    function onDocumentMouseDown(event) {
        event.preventDefault();
        isMouseDown = true;
        onMouseDownPositionX = event.clientX;
        onMouseDownPositionY = event.clientY;
        tempCameraRotationY = camera.rotation.y;
        tempCameraRotationX = camera.rotation.x;
    }

    function onDocumentMouseUp(event) {
        event.preventDefault();
        isMouseDown = false;
    }

    // globals
    var isMouseDown = false;
    var onMouseDownPositionX = 0;
    var onMouseDownPositionY = 0;
    var tempCameraRotationY = 0;
    var tempCameraRotationX = 0;

    document.addEventListener( 'mousemove', onDocumentMouseMove, false );
    document.addEventListener( 'mousedown', onDocumentMouseDown, false );
    document.addEventListener( 'mouseup', onDocumentMouseUp, false );
    window.addEventListener( 'resize', onWindowResize );

    init();
    buildScene();
    animate();

</script>
</body>
</html>